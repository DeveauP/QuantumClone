#'  Preclustering method
#' 
#' This method clusters mutations based on the probability that they are from the same 
#' distribution.
#' It first computes the zscore associated with a normalized number of alternative reads and depth.
#' The "normalized" number of reads is the number of alternative reads expected if the mutation was at a single 
#' copy in a diploid genome.
#' 
#' @param Schrod_cells The classic output from Schrodinger function
#' @return returns a list with:
#' \describe{
#'  \item{similarityMatrix}{ The matrix of probabilities}
#'  \item{distance}{The dissimilarity matrix}
#'  \item{tree}{The tree obtained by hierachical clustering of the dissimilarity matrix using "ward.D2" method}
#'  }
#'  
#'  @importFrom stats hclust as.dist cutree hclust
Cellular_preclustering<-function(Schrod_cells){
  for(i in 1:length(Schrod_cells)){
    Schrod_cells[[i]]$Norm_Alt<-round(
      Schrod_cells[[i]]$Alt * Schrod_cells[[i]]$NCh / (2 * Schrod_cells[[i]]$NC)
    )
  }
  
  
  DistMat<-ProbDistMatrix(Schrod_cells)
  dissimMatrix<-as.dist(1-DistMat)
  tree<-hclust(d = dissimMatrix,method = "ward.D2")
  #cut_tree<-cutree(tree = tree,k = majority)
  result<-list(similarityMatrix = DistMat,
               distance = dissimMatrix,
               tree = tree
               )
  result 
}


#' Create priors from hierarchical clustering
#' 
#' Creates weights and position priors from the hierachical clustering (tree) given
#' a number of clusters Nclust. The centers of each cluster is found by
#' \eqn{Center = \frac{\sum\limits_{m \in cluster}{Normalized Alt_{m}}}{\sum\limits_{m \in cluster}{Normalized Alt_{m}}}}
#' @param tree The tree generated by Cellular_preclustering
#' @param Schrod_cells The classic output from Schrodinger function
#' @param NClus the number of clusters to cut the data
#' @return returns a list with:
#' \describe{
#'  \item{weigths}{The proportion of mutations in each cluster}
#'  \item{centers}{A list with a numeric vector for each sample, with the cellularity of each cluster}
#'  }
#'  
#'  @importFrom stats cutree
Create_prior_cutTree<-function(tree,Schrod_cells,NClus){
  for(i in 1:length(Schrod_cells)){
    Schrod_cells[[i]]$Norm_Alt<-round(
      Schrod_cells[[i]]$Alt * Schrod_cells[[i]]$NCh / (2 * Schrod_cells[[i]]$NC)
    )
  }
  clustering<-cutree(tree,k = NClus)
  
  weights<-table(clustering)/length(clustering)
  centers<-list()
  for(i in 1:length(Schrod_cells)){
    
    centers[[i]]<-2 * unlist(sapply(as.numeric(names(weights)),
                         function(cl){
                           sum(Schrod_cells[[i]]$Norm_Alt[clustering==cl])/sum(Schrod_cells[[i]]$Depth[clustering==cl])
                         }
                         )
    )
    centers[[i]][centers[[i]]>1]<-1
  }
  
  list(weights = weights,centers = centers)
}

#'  Distance
#' 
#' Creates a matrix of distance between two points based on the p-value to be from the same distribution
#' @param Schrod_cells The classic output from Schrodinger function, with the normalized Alt
#' @return returns a square numeric matrix
#' @importFrom stats pnorm
ProbDistMatrix<-function(Schrod_cells){
  result<-matrix(0,nrow = nrow(Schrod_cells[[1]]),ncol = nrow(Schrod_cells[[1]]))
  for(l in 1:length(Schrod_cells)){
    result<-result+zscore(Schrod_cells[[l]]$Depth,Schrod_cells[[l]]$Norm_Alt)
  }
  2*pnorm(-result**(1/2))
  
}

#'  Z-score
#' 
#' Computes the z-score of mutations being from the same distribution 
#' @param Depth a numeric vector of depth of sequencing for each variant
#' @param Alt a numeric vector of the number of reads supporting each variant
#' @return returns a square numeric matrix
zscore<-function(Depth,Alt){
  n<-length(Depth)
  result<-matrix(ncol = n,nrow = n)
  for(i in 1:n){
    p<-(Alt+Alt[i])/(Depth + Depth[i])
    w<-which(p==0)
    p1<-Alt[i]/Depth[i]
    p2<-Alt/Depth
    result[,i]<-((p1-p2)**2)/(p*(1-p)*(1/Depth[i]+1/Depth))
    result[w,i]<-0
  }
  result
}


#' NMI
#' 
#' Computes the NMI based on the clustering
#' @param cut_tree a numeric vector of cluster selection
#' @param chr the ground truth for clusters
#' @return numeric value of NMI (between 0 and 1)
#' @examples
#' #1: Cluster data
#' FQC<-FlashQC(QuantumClone::Input_Example,conta = c(0,0),Nclus = 2:10)
#' 
#' #2: Compute NMI
#' NMI_cutree(FQC$clusters,chr = QuantumClone::Input_Example[[1]]$Chr)
#' @export
NMI_cutree<-function(cut_tree,chr){
  # Probabilities
  cluster<-as.numeric(as.character(cut_tree))
  clones<-chr
  
  P_cluster<-table(cluster)/length(cluster)
  P_clone<-table(clones)/length(clones)
  
  # Information entropy
  H_clone<--sum(P_clone*log(P_clone))
  H_cluster<--sum(P_cluster*log(P_cluster))
  
  A<-aggregate(rep(1, length(cluster)), 
               by = list(x= cluster,
                         y=clones ),
               sum)
  
  L<-log(A[,3]/(length(cluster)*P_cluster[A[,1]]*P_clone[A[,2]]))
  NMI<-2*sum(A[,3]/length(cluster)*L)/(H_clone+H_cluster)
  return(NMI)
  
}
#' Majority vote
#' 
#' @param index vector with number of clusters selected by indices
#' @return Numeric value of the number of clusters to chose
MajorityVote<-function(index){
  tab<-table(index)
  test<-tab==max(tab)
  if(sum(test)>1){ # return weighted center
    return(
      round(sum(tab[test]*as.numeric(names(tab[test])))/sum(tab[test]))
      
    )
    
  }
  else{
    return(names(which.max(tab)))
  }
}

#' Flash QuantumClone
#' 
#' Fast method to find clones without filtering for multiple states
#' @param Cells Input for QuantumClone with genotype required
#' @param conta vector with contamination fraction in each sample
#' @param Nclus vector with the number of clusters to test (alternatively only min and max values)
#' @examples
#' #1: Cluster data
#' FQC<-FlashQC(QuantumClone::Input_Example,conta = c(0,0),Nclus = 2:10)
#' 
#' @export
#' @importFrom NbClust NbClust
#' @seealso QuantumClone
FlashQC<-function(Cells,conta,Nclus){
  Schrod_cells<-Patient_schrodinger_cellularities(SNV_list = Cells,
                                                  contamination = conta,
                                                  Genotype_provided = TRUE)
  for(i in 1:length(Schrod_cells)){
    
    Schrod_cells[[i]]$Norm_Alt<-round(
      Schrod_cells[[i]]$Alt * Schrod_cells[[i]]$NCh / (2 * Schrod_cells[[i]]$NC)
    )
  }
  
  
  DistMat<-ProbDistMatrix(Schrod_cells)
  dissimMatrix<-as.dist(1-DistMat)
  tree<-hclust(d = dissimMatrix,method = "ward.D2")
  Cells<-matrix(data = 0,ncol = length(Schrod_cells),nrow = nrow(Schrod_cells[[1]]))
  for(i in 1:length(Schrod_cells)){
    Cells[,i]<-Schrod_cells[[i]]$Alt/Schrod_cells[[i]]$Depth*Schrod_cells[[i]]$NCh/(Schrod_cells[[i]]$NC * 1-conta[i])
    
  }
  index<- c("ch","ccc","gap")
  method<-"ward.D2"
  selected<-unlist(sapply(X =index,function(name){
    NbClust(data = Cells,diss = dissimMatrix, distance =  NULL,
            method = method,index = name,
            min.nc = min(Nclus),
            max.nc = max(Nclus)
    )$Best.nc["Number_clusters"]
  })
  )
  tree<-hclust(d = dissimMatrix,method = method)
  
  majority<-MajorityVote(selected)
  cut_tree<-cutree(tree = tree,k = majority)
  
  priors<-Create_prior_cutTree(tree = tree,
                               Schrod_cells = Schrod_cells,
                               NClus = majority
                              )
  result<-list(similarity = DistMat,
               distance = dissimMatrix,
               tree = tree,
               clusters = cut_tree,
               cluster_nb = selected,
               majority = majority,
               weights = priors$weights,
               centers = priors$centers
               )
  result 
  
}